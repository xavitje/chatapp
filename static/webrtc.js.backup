// WebRTC Video/Voice Call Manager for Call Rooms
console.log('✅ webrtc.js loaded');

class CallManager {
    constructor(ws, username) {
        this.ws = ws;
        this.username = username;
        this.peerConnections = {};  // Map of username -> RTCPeerConnection
        this.localStream = null;
        this.remoteStreams = {};  // Map of username -> MediaStream
        this.isCallActive = false;
        this.isMuted = false;
        this.isVideoOff = false;
        this.currentCallType = null; // 'audio' or 'video'
        this.currentCallRoom = null;  // Current call room slug
        this.callRoomMembers = [];  // List of usernames in current call room

        // ICE servers (STUN/TURN)
        this.iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
    }

    // Join a call room
    async joinCallRoom(callRoomSlug, callType = 'video') {
        try {
            this.currentCallType = callType;
            this.remotePeer = recipientUsername;

            // Get local media stream
            const constraints = {
                audio: true,
                video: callType === 'video'
            };

            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

            // Show call UI
            this.showCallUI(true, recipientUsername);

            // Display local video
            const localVideo = document.getElementById('local-video');
            if (localVideo) {
                localVideo.srcObject = this.localStream;
            }

            // Create peer connection
            this.createPeerConnection();

            // Add tracks to peer connection
            this.localStream.getTracks().forEach(track => {
                this.peerConnection.addTrack(track, this.localStream);
            });

            // Create offer
            const offer = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(offer);

            // Send offer via WebSocket
            this.sendSignal('call-offer', {
                to: recipientUsername,
                from: this.username,
                offer: offer,
                callType: callType
            });

            this.isCallActive = true;

        } catch (error) {
            console.error('Error starting call:', error);
            alert('Kon geen toegang krijgen tot camera/microfoon');
            this.endCall();
        }
    }

    // Handle incoming call offer
    async handleCallOffer(data) {
        try {
            this.remotePeer = data.from;
            this.currentCallType = data.callType;

            // Show incoming call UI
            const accept = confirm(`Inkomende ${data.callType === 'video' ? 'video' : 'audio'} oproep van ${data.from}. Accepteren?`);

            if (!accept) {
                this.sendSignal('call-reject', { to: data.from, from: this.username });
                return;
            }

            // Get local media stream
            const constraints = {
                audio: true,
                video: data.callType === 'video'
            };

            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

            // Show call UI
            this.showCallUI(false, data.from);

            // Display local video
            const localVideo = document.getElementById('local-video');
            if (localVideo) {
                localVideo.srcObject = this.localStream;
            }

            // Create peer connection
            this.createPeerConnection();

            // Add tracks
            this.localStream.getTracks().forEach(track => {
                this.peerConnection.addTrack(track, this.localStream);
            });

            // Set remote description
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));

            // Create answer
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);

            // Send answer
            this.sendSignal('call-answer', {
                to: data.from,
                from: this.username,
                answer: answer
            });

            this.isCallActive = true;

        } catch (error) {
            console.error('Error handling call offer:', error);
            alert('Kon geen toegang krijgen tot camera/microfoon');
            this.endCall();
        }
    }

    // Handle call answer
    async handleCallAnswer(data) {
        try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        } catch (error) {
            console.error('Error handling call answer:', error);
        }
    }

    // Handle ICE candidate
    async handleIceCandidate(data) {
        try {
            if (this.peerConnection) {
                await this.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        } catch (error) {
            console.error('Error handling ICE candidate:', error);
        }
    }

    // Handle call end
    handleCallEnd() {
        this.endCall();
        alert('Oproep beëindigd door andere gebruiker');
    }

    // Create RTCPeerConnection
    createPeerConnection() {
        this.peerConnection = new RTCPeerConnection(this.iceServers);

        // Handle ICE candidates
        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                this.sendSignal('ice-candidate', {
                    to: this.remotePeer,
                    from: this.username,
                    candidate: event.candidate
                });
            }
        };

        // Handle remote stream
        this.peerConnection.ontrack = (event) => {
            const remoteVideo = document.getElementById('remote-video');
            if (remoteVideo && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                this.remoteStream = event.streams[0];
            }
        };

        // Handle connection state changes
        this.peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', this.peerConnection.connectionState);
            if (this.peerConnection.connectionState === 'disconnected' ||
                this.peerConnection.connectionState === 'failed') {
                this.endCall();
            }
        };
    }

    // Send signaling message via WebSocket
    sendSignal(type, data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({
                type: type,
                ...data
            }));
        }
    }

    // Toggle mute
    toggleMute() {
        if (this.localStream) {
            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                this.isMuted = !audioTrack.enabled;
                return this.isMuted;
            }
        }
        return false;
    }

    // Toggle video
    toggleVideo() {
        if (this.localStream) {
            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                this.isVideoOff = !videoTrack.enabled;
                return this.isVideoOff;
            }
        }
        return false;
    }

    // End call
    endCall() {
        // Send end call signal
        if (this.remotePeer) {
            this.sendSignal('call-end', {
                to: this.remotePeer,
                from: this.username
            });
        }

        // Stop all tracks
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => track.stop());
            this.localStream = null;
        }

        // Close peer connection
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }

        // Hide call UI
        this.hideCallUI();

        this.isCallActive = false;
        this.remotePeer = null;
        this.remoteStream = null;
    }

    // Show call UI
    showCallUI(isOutgoing, peerName) {
        const callModal = document.getElementById('call-modal');
        const callStatus = document.getElementById('call-status');
        const peerNameEl = document.getElementById('call-peer-name');

        if (callModal) {
            callModal.classList.remove('hidden');
            peerNameEl.textContent = peerName;
            callStatus.textContent = isOutgoing ? 'Oproep plaatsen...' : 'Verbonden';
        }
    }

    // Hide call UI
    hideCallUI() {
        const callModal = document.getElementById('call-modal');
        if (callModal) {
            callModal.classList.add('hidden');
        }

        // Clear video elements
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        if (localVideo) localVideo.srcObject = null;
        if (remoteVideo) remoteVideo.srcObject = null;
    }
}
